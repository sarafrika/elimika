package apps.sarafrika.elimika.tenancy.services.impl;

import apps.sarafrika.elimika.common.event.organisation.OrganisationCreationEvent;
import apps.sarafrika.elimika.common.event.organisation.SuccessfulOrganisationCreationEvent;
import apps.sarafrika.elimika.common.exceptions.ResourceNotFoundException;
import apps.sarafrika.elimika.common.util.GenericSpecificationBuilder;
import apps.sarafrika.elimika.tenancy.dto.OrganisationDTO;
import apps.sarafrika.elimika.tenancy.dto.UserDTO;
import apps.sarafrika.elimika.tenancy.entity.*;
import apps.sarafrika.elimika.tenancy.factory.OrganisationFactory;
import apps.sarafrika.elimika.tenancy.factory.UserFactory;
import apps.sarafrika.elimika.tenancy.repository.*;
import apps.sarafrika.elimika.tenancy.services.OrganisationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.modulith.events.ApplicationModuleListener;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrganisationServiceImpl implements OrganisationService {

    @Value("${app.keycloak.realm}")
    private String realm;

    private final ApplicationEventPublisher eventPublisher;
    private final OrganisationRepository organisationRepository;
    private final UserRepository userRepository;
    private final UserDomainRepository userDomainRepository;
    private final UserOrganisationDomainMappingRepository userOrganisationDomainMappingRepository;
    private final TrainingBranchRepository trainingBranchRepository;
    private final GenericSpecificationBuilder<Organisation> specificationBuilder;

    @Override
    @Transactional
    public OrganisationDTO createOrganisation(OrganisationDTO organisationDTO) {
        log.debug("Creating new organisation: {}", organisationDTO.name());

        try {
            Organisation organisation = OrganisationFactory.toEntity(organisationDTO);

            // Auto-generate slug from name
            organisation.setSlug(organisation.getName().replaceAll("\\s+", "-").toLowerCase());

            // Check for domain uniqueness (code is auto-generated by database)
            if (organisation.getDomain() != null && organisationRepository.existsByDomain(organisation.getDomain())) {
                throw new IllegalArgumentException("Organisation with this domain already exists");
            }

            organisation = organisationRepository.save(organisation);

            publishOrganisationCreationEvent(organisation);

            log.info("Successfully created organisation with UUID: {} and code: {}",
                    organisation.getUuid(), organisation.getCode());
            return OrganisationFactory.toDTO(organisation);
        } catch (Exception e) {
            log.error("Failed to create organisation: {}", organisationDTO.name(), e);
            throw new RuntimeException("Failed to create organisation.", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public OrganisationDTO getOrganisationByUuid(UUID uuid) {
        log.debug("Fetching organisation by UUID: {}", uuid);
        return organisationRepository.findByUuidAndDeletedFalse(uuid)
                .map(OrganisationFactory::toDTO)
                .orElseThrow(() -> {
                    log.warn("Organisation not found for UUID: {}", uuid);
                    return new ResourceNotFoundException("Organisation not found for UUID: " + uuid);
                });
    }

    @Override
    @Transactional(readOnly = true)
    public Page<OrganisationDTO> getAllOrganisations(Pageable pageable) {
        log.debug("Fetching all organisations");
        return organisationRepository.findByDeletedFalse(pageable)
                .map(OrganisationFactory::toDTO);
    }

    @Override
    @Transactional
    public OrganisationDTO updateOrganisation(UUID uuid, OrganisationDTO organisationDTO) {
        log.debug("Updating organisation with UUID: {}", uuid);

        try {
            Organisation organisation = findOrganisationOrThrow(uuid);
            updateOrganisationFields(organisation, organisationDTO);

            // Update slug if name changed
            organisation.setSlug(organisation.getName().replaceAll("\\s+", "-").toLowerCase());

            organisation = organisationRepository.save(organisation);

            log.info("Successfully updated organisation with UUID: {}", uuid);
            return OrganisationFactory.toDTO(organisation);
        } catch (ResourceNotFoundException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to update organisation with UUID: {}", uuid, e);
            throw new RuntimeException("Failed to update organisation: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional
    public void deleteOrganisation(UUID uuid) {
        log.debug("Soft deleting organisation with UUID: {}", uuid);

        try {
            Organisation organisation = findOrganisationOrThrow(uuid);

            // Soft delete all user mappings for this organisation
            List<UserOrganisationDomainMapping> mappings =
                    userOrganisationDomainMappingRepository.findActiveByOrganisation(uuid);
            mappings.forEach(mapping -> {
                mapping.setActive(false);
                mapping.setEndDate(LocalDate.now());
                mapping.setDeleted(true);
            });
            userOrganisationDomainMappingRepository.saveAll(mappings);

            // Soft delete the organisation
            organisation.setDeleted(true);
            organisation.setActive(false);
            organisationRepository.save(organisation);
            log.info("Successfully soft deleted organisation with UUID: {}", uuid);
        } catch (ResourceNotFoundException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to delete organisation with UUID: {}", uuid, e);
            throw new RuntimeException("Failed to delete organisation: " + e.getMessage(), e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public Page<OrganisationDTO> search(Map<String, String> searchParams, Pageable pageable) {
        Specification<Organisation> spec = specificationBuilder.buildSpecification(Organisation.class, searchParams);
        // Add deleted=false filter to search
        Specification<Organisation> notDeletedSpec = (root, query, criteriaBuilder) ->
                criteriaBuilder.isFalse(root.get("deleted"));
        Specification<Organisation> combinedSpec = spec.and(notDeletedSpec);

        Page<Organisation> organisations = organisationRepository.findAll(combinedSpec, pageable);
        return organisations.map(OrganisationFactory::toDTO);
    }

    @Override
    @Transactional
    public void inviteUserToOrganisation(UUID organisationUuid, String email, String domainName, UUID branchUuid) {
        log.debug("Inviting user with email {} to organisation {} with domain {}", email, organisationUuid, domainName);

        Organisation organisation = findOrganisationOrThrow(organisationUuid);
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with email: " + email));
        UserDomain domain = findDomainByNameOrThrow(domainName);

        // Validate branch belongs to organisation if provided
        if (branchUuid != null) {
            TrainingBranch branch = trainingBranchRepository.findByUuid(branchUuid)
                    .orElseThrow(() -> new ResourceNotFoundException("Training branch not found"));

            if (!branch.getOrganisationUuid().equals(organisationUuid)) {
                throw new IllegalArgumentException("Training branch does not belong to the specified organisation");
            }
        }

        // Check if mapping already exists
        Optional<UserOrganisationDomainMapping> existingMapping =
                userOrganisationDomainMappingRepository.findActiveByUserAndOrganisation(user.getUuid(), organisationUuid);

        if (existingMapping.isPresent()) {
            log.warn("User {} is already associated with organisation {}", email, organisationUuid);
            throw new IllegalStateException("User is already associated with this organisation");
        }

        // Create new mapping
        UserOrganisationDomainMapping mapping = UserOrganisationDomainMapping.builder()
                .userUuid(user.getUuid())
                .organisationUuid(organisationUuid)
                .domainUuid(domain.getUuid())
                .branchUuid(branchUuid)
                .active(true)
                .startDate(LocalDate.now())
                .createdBy("system") // TODO: Replace with actual user context
                .build();

        userOrganisationDomainMappingRepository.save(mapping);

        log.info("Successfully invited user {} to organisation {} with domain {}", email, organisationUuid, domainName);

        // TODO: Send invitation email
    }

    @Override
    @Transactional(readOnly = true)
    public List<UserDTO> getOrganisationUsers(UUID organisationUuid) {
        List<UserOrganisationDomainMapping> mappings =
                userOrganisationDomainMappingRepository.findActiveByOrganisation(organisationUuid);

        return mappings.stream()
                .map(mapping -> {
                    User user = userRepository.findByUuid(mapping.getUserUuid())
                            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
                    UserDomain domain = userDomainRepository.findByUuid(mapping.getDomainUuid())
                            .orElseThrow(() -> new ResourceNotFoundException("Domain not found"));

                    // Get all user domains for this user
                    List<String> userDomains = getUserDomainsForUser(user.getUuid());
                    return UserFactory.toDTO(user, userDomains);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<UserDTO> getOrganisationUsersByDomain(UUID organisationUuid, String domainName) {
        UserDomain domain = findDomainByNameOrThrow(domainName);

        List<UserOrganisationDomainMapping> mappings =
                userOrganisationDomainMappingRepository.findActiveByOrganisationAndDomain(organisationUuid, domain.getUuid());

        return mappings.stream()
                .map(mapping -> {
                    User user = userRepository.findByUuid(mapping.getUserUuid())
                            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
                    List<String> userDomains = getUserDomainsForUser(user.getUuid());
                    return UserFactory.toDTO(user, userDomains);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void removeUserFromOrganisation(UUID organisationUuid, UUID userUuid) {
        log.debug("Removing user {} from organisation {}", userUuid, organisationUuid);

        UserOrganisationDomainMapping mapping = userOrganisationDomainMappingRepository
                .findActiveByUserAndOrganisation(userUuid, organisationUuid)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "No active mapping found for user and organisation"));

        // Soft delete - set end date and deactivate
        mapping.setActive(false);
        mapping.setEndDate(LocalDate.now());

        userOrganisationDomainMappingRepository.save(mapping);
        log.info("Removed user {} from organisation {}", userUuid, organisationUuid);
    }

    @Override
    @Transactional
    public void updateUserRoleInOrganisation(UUID organisationUuid, UUID userUuid, String newDomainName) {
        log.debug("Updating user {} role in organisation {} to {}", userUuid, organisationUuid, newDomainName);

        UserDomain newDomain = findDomainByNameOrThrow(newDomainName);

        UserOrganisationDomainMapping mapping = userOrganisationDomainMappingRepository
                .findActiveByUserAndOrganisation(userUuid, organisationUuid)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "No active mapping found for user and organisation"));

        mapping.setDomainUuid(newDomain.getUuid());

        userOrganisationDomainMappingRepository.save(mapping);
        log.info("Updated user {} role in organisation {} to {}", userUuid, organisationUuid, newDomainName);
    }

    @Override
    @Transactional(readOnly = true)
    public List<OrganisationDTO> getUserOrganisations(UUID userUuid) {
        List<UserOrganisationDomainMapping> mappings =
                userOrganisationDomainMappingRepository.findActiveByUser(userUuid);

        return mappings.stream()
                .map(mapping -> {
                    Organisation organisation = organisationRepository.findByUuid(mapping.getOrganisationUuid())
                            .orElseThrow(() -> new ResourceNotFoundException("Organisation not found"));
                    return OrganisationFactory.toDTO(organisation);
                })
                .distinct()
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public boolean isUserInOrganisation(UUID organisationUuid, UUID userUuid) {
        return userOrganisationDomainMappingRepository
                .findActiveByUserAndOrganisation(userUuid, organisationUuid)
                .isPresent();
    }

    @Override
    @Transactional(readOnly = true)
    public String getUserRoleInOrganisation(UUID organisationUuid, UUID userUuid) {
        UserOrganisationDomainMapping mapping = userOrganisationDomainMappingRepository
                .findActiveByUserAndOrganisation(userUuid, organisationUuid)
                .orElseThrow(() -> new ResourceNotFoundException(
                        "User is not associated with this organisation"));

        UserDomain domain = userDomainRepository.findByUuid(mapping.getDomainUuid())
                .orElseThrow(() -> new ResourceNotFoundException("Domain not found"));

        return domain.getDomainName();
    }

    @ApplicationModuleListener
    void onOrganisationCreation(SuccessfulOrganisationCreationEvent event) {
        log.debug("Processing successful organisation creation event for UUID: {}", event.blastWaveId());

        try {
            Organisation organisation = findOrganisationOrThrow(event.blastWaveId());
            organisation.setKeycloakId(event.keycloakId());
            organisationRepository.save(organisation);
            log.info("Successfully processed organisation creation event for UUID: {}", event.blastWaveId());
        } catch (Exception e) {
            log.error("Failed to process organisation creation event for UUID: {}", event.blastWaveId(), e);
            throw new RuntimeException("Failed to process organisation creation event: " + e.getMessage(), e);
        }
    }

    // Private helper methods
    private Organisation findOrganisationOrThrow(UUID uuid) {
        return organisationRepository.findByUuidAndDeletedFalse(uuid)
                .orElseThrow(() -> new ResourceNotFoundException("Organisation not found for UUID: " + uuid));
    }

    private UserDomain findDomainByNameOrThrow(String domainName) {
        return userDomainRepository.findByDomainName(domainName)
                .orElseThrow(() -> new IllegalArgumentException("No known domain with the provided name: " + domainName));
    }

    private List<String> getUserDomainsForUser(UUID userUuid) {
        List<UserOrganisationDomainMapping> mappings =
                userOrganisationDomainMappingRepository.findActiveByUser(userUuid);

        return mappings.stream()
                .map(mapping -> {
                    UserDomain domain = userDomainRepository.findByUuid(mapping.getDomainUuid())
                            .orElseThrow(() -> new ResourceNotFoundException("Domain not found"));
                    return domain.getDomainName();
                })
                .distinct()
                .collect(Collectors.toList());
    }

    private void updateOrganisationFields(Organisation organisation, OrganisationDTO dto) {
        organisation.setName(dto.name());
        organisation.setDescription(dto.description());
        organisation.setActive(dto.active());
        organisation.setLicenceNo(dto.licenceNo());
        organisation.setDomain(dto.domain());
        organisation.setUserUuid(dto.userUuid());
        organisation.setLocation(dto.location());
        organisation.setCountry(dto.country());
    }

    private void publishOrganisationCreationEvent(Organisation organisation) {
        eventPublisher.publishEvent(new OrganisationCreationEvent(
                organisation.getName(),
                organisation.getSlug(),
                organisation.getDescription(),
                realm,
                organisation.getDomain(),
                organisation.getUuid()
        ));
    }
}