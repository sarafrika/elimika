package apps.sarafrika.elimika.instructor.dto;

import apps.sarafrika.elimika.common.enums.DocumentStatus;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Instructor Document Data Transfer Object
 * <p>
 * Represents document records associated with instructor profiles in the Sarafrika Elimika system.
 * This includes educational certificates, experience documents, professional memberships,
 * and other verification documents used to validate instructor credentials.
 *
 * @author Wilfred Njuguna
 * @version 1.0
 * @since 2024-06-30
 */
@Schema(
        name = "InstructorDocument",
        description = "Document record for instructor credential verification including educational certificates, experience documents, and professional memberships",
        example = """
        {
            "uuid": "doc12345-6789-abcd-ef01-234567890abc",
            "instructor_uuid": "i1s2t3r4-5u6c-7t8o-9r10-abcdefghijkl",
            "document_type_uuid": "dt123456-7890-abcd-ef01-234567890abc",
            "education_uuid": "edu12345-6789-abcd-ef01-234567890abc",
            "experience_uuid": null,
            "membership_uuid": null,
            "original_filename": "AWS_Solutions_Architect_Certificate.pdf",
            "stored_filename": "instructor_doc_20240615_143022_abc123.pdf",
            "file_path": "/documents/instructors/2024/06/instructor_doc_20240615_143022_abc123.pdf",
            "file_size_bytes": 2048576,
            "mime_type": "application/pdf",
            "file_hash": "sha256:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6",
            "title": "AWS Certified Solutions Architect - Professional Certificate",
            "description": "Professional certification in cloud architecture and solutions design",
            "upload_date": "2024-06-15T14:30:22",
            "is_verified": true,
            "verified_by": "admin@sarafrika.com",
            "verified_at": "2024-06-16T09:15:00",
            "verification_notes": "Certificate verified against AWS official database",
            "status": "APPROVED",
            "expiry_date": "2027-06-15",
            "created_date": "2024-06-15T14:30:22",
            "created_by": "instructor@example.com",
            "updated_date": "2024-06-16T09:15:00",
            "updated_by": "admin@sarafrika.com",
            "file_size_formatted": "2.0 MB",
            "is_expired": false,
            "days_until_expiry": 1095,
            "is_pending_verification": false,
            "has_expiry_date": true,
            "verification_status": "VERIFIED"
        }
        """
)
public record InstructorDocumentDTO(

        @Schema(
                description = "**[READ-ONLY]** Unique system identifier for the document record. Auto-generated by the system.",
                example = "doc12345-6789-abcd-ef01-234567890abc",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "uuid", access = JsonProperty.Access.READ_ONLY)
        UUID uuid,

        @Schema(
                description = "**[REQUIRED]** Reference to the instructor profile UUID. Links document to specific instructor.",
                example = "i1s2t3r4-5u6c-7t8o-9r10-abcdefghijkl",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Instructor UUID is required")
        @JsonProperty("instructor_uuid")
        UUID instructorUuid,

        @Schema(
                description = "**[REQUIRED]** Reference to the document type UUID. Defines the category and validation rules for this document.",
                example = "dt123456-7890-abcd-ef01-234567890abc",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Document type UUID is required")
        @JsonProperty("document_type_uuid")
        UUID documentTypeUuid,

        @Schema(
                description = "**[OPTIONAL]** Reference to specific education record UUID if this document supports an educational qualification.",
                example = "edu12345-6789-abcd-ef01-234567890abc",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("education_uuid")
        UUID educationUuid,

        @Schema(
                description = "**[OPTIONAL]** Reference to specific experience record UUID if this document supports work experience.",
                example = "exp12345-6789-abcd-ef01-234567890abc",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("experience_uuid")
        UUID experienceUuid,

        @Schema(
                description = "**[OPTIONAL]** Reference to specific membership record UUID if this document supports professional body membership.",
                example = "mem12345-6789-abcd-ef01-234567890abc",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("membership_uuid")
        UUID membershipUuid,

        @Schema(
                description = "**[REQUIRED]** Original filename as uploaded by the user. Preserved for user reference and display purposes.",
                example = "AWS_Solutions_Architect_Certificate.pdf",
                maxLength = 255,
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotBlank(message = "Original filename is required")
        @Size(max = 255, message = "Original filename must not exceed 255 characters")
        @JsonProperty("original_filename")
        String originalFilename,

        @Schema(
                description = "**[READ-ONLY]** System-generated filename for secure storage. Used internally for file system operations.",
                example = "instructor_doc_20240615_143022_abc123.pdf",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "stored_filename", access = JsonProperty.Access.READ_ONLY)
        String storedFilename,

        @Schema(
                description = "**[READ-ONLY]** Full file system path where the document is stored. Used for internal file operations.",
                example = "/documents/instructors/2024/06/instructor_doc_20240615_143022_abc123.pdf",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "file_path", access = JsonProperty.Access.READ_ONLY)
        String filePath,

        @Schema(
                description = "**[READ-ONLY]** File size in bytes. Automatically calculated during upload.",
                example = "2048576",
                minimum = "1",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Positive(message = "File size must be positive")
        @JsonProperty(value = "file_size_bytes", access = JsonProperty.Access.READ_ONLY)
        Long fileSizeBytes,

        @Schema(
                description = "**[READ-ONLY]** MIME type of the uploaded file. Automatically detected during upload.",
                example = "application/pdf",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "mime_type", access = JsonProperty.Access.READ_ONLY)
        String mimeType,

        @Schema(
                description = "**[READ-ONLY]** SHA-256 hash of the file content. Used for integrity verification and duplicate detection.",
                example = "sha256:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "file_hash", access = JsonProperty.Access.READ_ONLY)
        String fileHash,

        @Schema(
                description = "**[REQUIRED]** Descriptive title for the document. Used for identification and display in document lists.",
                example = "AWS Certified Solutions Architect - Professional Certificate",
                maxLength = 255,
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotBlank(message = "Document title is required")
        @Size(max = 255, message = "Title must not exceed 255 characters")
        @JsonProperty("title")
        String title,

        @Schema(
                description = "**[OPTIONAL]** Detailed description of the document content and its relevance to instructor qualifications.",
                example = "Professional certification in cloud architecture and solutions design, demonstrating expertise in AWS services and best practices.",
                maxLength = 2000,
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Size(max = 2000, message = "Description must not exceed 2000 characters")
        @JsonProperty("description")
        String description,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the document was uploaded. Automatically set by the system.",
                example = "2024-06-15T14:30:22",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "upload_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime uploadDate,

        @Schema(
                description = "**[READ-ONLY]** Verification status of the document. True if verified by admin, false if not verified, null if pending.",
                example = "true",
                nullable = true,
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "is_verified", access = JsonProperty.Access.READ_ONLY)
        Boolean isVerified,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the administrator who verified this document.",
                example = "admin@sarafrika.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "verified_by", access = JsonProperty.Access.READ_ONLY)
        String verifiedBy,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the document was verified. Set automatically when verification is completed.",
                example = "2024-06-16T09:15:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "verified_at", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime verifiedAt,

        @Schema(
                description = "**[READ-ONLY]** Notes or comments from the verification process. Includes details about verification outcome.",
                example = "Certificate verified against AWS official database. Valid credential confirmed.",
                maxLength = 2000,
                nullable = true,
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "verification_notes", access = JsonProperty.Access.READ_ONLY)
        String verificationNotes,

        @Schema(
                description = "**[READ-ONLY]** Current status of the document in the verification workflow.",
                example = "APPROVED",
                allowableValues = {"PENDING", "APPROVED", "REJECTED", "EXPIRED", "UNDER_REVIEW"},
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "status", access = JsonProperty.Access.READ_ONLY)
        DocumentStatus status,

        @Schema(
                description = "**[OPTIONAL]** Expiry date of the document if applicable. Used for certificates and time-limited credentials.",
                example = "2027-06-15",
                format = "date",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("expiry_date")
        LocalDate expiryDate,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the document record was first created. Automatically set by the system.",
                example = "2024-06-15T14:30:22",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime createdDate,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who created this document record.",
                example = "instructor@example.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_by", access = JsonProperty.Access.READ_ONLY)
        String createdBy,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the document record was last modified. Automatically updated by the system.",
                example = "2024-06-16T09:15:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime updatedDate,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who last modified this document record.",
                example = "admin@sarafrika.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_by", access = JsonProperty.Access.READ_ONLY)
        String updatedBy

) {

    /**
     * Returns a human-readable formatted file size.
     *
     * @return Formatted file size string (e.g., "2.5 MB", "1.2 KB")
     */
    @JsonProperty(value = "file_size_formatted", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable formatted file size.",
            example = "2.0 MB",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getFileSizeFormatted() {
        if (fileSizeBytes == null || fileSizeBytes <= 0) {
            return "0 B";
        }

        final String[] units = {"B", "KB", "MB", "GB", "TB"};
        int unitIndex = 0;
        double size = fileSizeBytes.doubleValue();

        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }

        return String.format("%.1f %s", size, units[unitIndex]);
    }

    /**
     * Checks if the document is expired based on expiry date.
     *
     * @return true if document has expired, false otherwise
     */
    @JsonProperty(value = "is_expired", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the document has expired based on the expiry date.",
            example = "false",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isExpired() {
        return expiryDate != null && expiryDate.isBefore(LocalDate.now());
    }

    /**
     * Returns the number of days until document expiry.
     *
     * @return Days until expiry, null if no expiry date or already expired
     */
    @JsonProperty(value = "days_until_expiry", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Number of days until document expiry. Returns null if no expiry date or already expired.",
            example = "1095",
            nullable = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public Integer getDaysUntilExpiry() {
        if (expiryDate == null || isExpired()) {
            return null;
        }
        return (int) LocalDate.now().until(expiryDate).getDays();
    }

    /**
     * Checks if the document is pending verification.
     *
     * @return true if verification status is null or false
     */
    @JsonProperty(value = "is_pending_verification", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the document is pending verification.",
            example = "false",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isPendingVerification() {
        return isVerified == null || !isVerified;
    }

    /**
     * Checks if the document has an expiry date configured.
     *
     * @return true if expiry date is set, false otherwise
     */
    @JsonProperty(value = "has_expiry_date", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the document has an expiry date configured.",
            example = "true",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean hasExpiryDate() {
        return expiryDate != null;
    }

    /**
     * Returns a human-readable verification status.
     *
     * @return Verification status as string
     */
    @JsonProperty(value = "verification_status", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable verification status of the document.",
            example = "VERIFIED",
            allowableValues = {"VERIFIED", "PENDING", "REJECTED"},
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getVerificationStatus() {
        if (isVerified == null) {
            return "PENDING";
        }
        return isVerified ? "VERIFIED" : "REJECTED";
    }
}