package apps.sarafrika.elimika.classes.dto;

import apps.sarafrika.elimika.classes.util.enums.RecurrenceType;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.time.LocalDate;
import java.util.UUID;

/**
 * Recurrence Pattern Data Transfer Object
 * <p>
 * Represents recurrence pattern configurations for class scheduling in the Sarafrika Elimika system.
 * This defines how classes repeat over time with support for daily, weekly, and monthly patterns
 * with customizable intervals and end conditions.
 *
 * @author Wilfred Njuguna
 * @version 1.0
 * @since 2024-09-05
 */
@Schema(
        name = "RecurrencePattern",
        description = "Recurrence pattern configuration for class scheduling with support for daily, weekly, and monthly patterns",
        example = """
        {
            "uuid": "rp123456-7890-abcd-ef01-234567890abc",
            "recurrence_type": "WEEKLY",
            "interval_value": 2,
            "days_of_week": "MONDAY,WEDNESDAY,FRIDAY",
            "day_of_month": null,
            "end_date": "2024-12-31",
            "occurrence_count": 50
        }
        """
)
public record RecurrencePatternDTO(

        @Schema(
                description = "**[READ-ONLY]** Unique system identifier for the recurrence pattern. Auto-generated by the system.",
                example = "rp123456-7890-abcd-ef01-234567890abc",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "uuid", access = JsonProperty.Access.READ_ONLY)
        UUID uuid,

        @Schema(
                description = "**[REQUIRED]** Type of recurrence pattern. Defines the base frequency of repetition.",
                example = "WEEKLY",
                allowableValues = {"DAILY", "WEEKLY", "MONTHLY"},
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Recurrence type is required")
        @JsonProperty("recurrence_type")
        RecurrenceType recurrenceType,

        @Schema(
                description = "**[OPTIONAL]** Interval value for recurrence. For example, 2 means every 2 weeks for WEEKLY pattern.",
                example = "2",
                minimum = "1",
                maximum = "365",
                nullable = false,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Positive(message = "Interval value must be positive")
        @JsonProperty("interval_value")
        Integer intervalValue,

        @Schema(
                description = "**[OPTIONAL]** Comma-separated list of days for WEEKLY recurrence. Valid values: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.",
                example = "MONDAY,WEDNESDAY,FRIDAY",
                maxLength = 100,
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("days_of_week")
        String daysOfWeek,

        @Schema(
                description = "**[OPTIONAL]** Specific day of month for MONTHLY recurrence. Must be between 1 and 31.",
                example = "15",
                minimum = "1",
                maximum = "31",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Min(value = 1, message = "Day of month must be at least 1")
        @Max(value = 31, message = "Day of month must be at most 31")
        @JsonProperty("day_of_month")
        Integer dayOfMonth,

        @Schema(
                description = "**[OPTIONAL]** End date for the recurrence pattern. If null, pattern continues indefinitely unless limited by occurrence count.",
                example = "2024-12-31",
                format = "date",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("end_date")
        LocalDate endDate,

        @Schema(
                description = "**[OPTIONAL]** Maximum number of occurrences for this pattern. If null, pattern continues until end date or indefinitely.",
                example = "50",
                minimum = "1",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Positive(message = "Occurrence count must be positive")
        @JsonProperty("occurrence_count")
        Integer occurrenceCount

) {

    /**
     * Checks if the recurrence pattern is currently active.
     *
     * @return true if pattern is active (not ended), false otherwise
     */
    @JsonProperty(value = "is_active", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the recurrence pattern is currently active based on end date.",
            example = "true",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isActive() {
        return endDate == null || !endDate.isBefore(LocalDate.now());
    }

    /**
     * Checks if this is an indefinite pattern (no end date or occurrence limit).
     *
     * @return true if pattern has no end conditions, false otherwise
     */
    @JsonProperty(value = "is_indefinite", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the pattern continues indefinitely (no end date or occurrence limit).",
            example = "false",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isIndefinite() {
        return endDate == null && occurrenceCount == null;
    }

    /**
     * Returns a human-readable description of the recurrence pattern.
     *
     * @return Formatted description string
     */
    @JsonProperty(value = "pattern_description", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable description of the recurrence pattern.",
            example = "Every 2 weeks on Monday, Wednesday, Friday until December 31, 2024",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getPatternDescription() {
        StringBuilder description = new StringBuilder();
        
        // Base pattern
        if (intervalValue != null && intervalValue > 1) {
            description.append("Every ").append(intervalValue).append(" ");
        } else {
            description.append("Every ");
        }
        
        switch (recurrenceType) {
            case DAILY -> description.append(intervalValue != null && intervalValue > 1 ? "days" : "day");
            case WEEKLY -> {
                description.append(intervalValue != null && intervalValue > 1 ? "weeks" : "week");
                if (daysOfWeek != null && !daysOfWeek.trim().isEmpty()) {
                    description.append(" on ").append(daysOfWeek.replace(",", ", "));
                }
            }
            case MONTHLY -> {
                description.append(intervalValue != null && intervalValue > 1 ? "months" : "month");
                if (dayOfMonth != null) {
                    description.append(" on day ").append(dayOfMonth);
                }
            }
        }
        
        // End condition
        if (endDate != null) {
            description.append(" until ").append(endDate);
        } else if (occurrenceCount != null) {
            description.append(" for ").append(occurrenceCount).append(" occurrences");
        }
        
        return description.toString();
    }
}