package apps.sarafrika.elimika.availability.dto;

import apps.sarafrika.elimika.shared.enums.AvailabilityType;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.UUID;

/**
 * Availability Slot Data Transfer Object
 * <p>
 * Represents instructor availability slots in the Sarafrika Elimika system.
 * This defines when an instructor is available for teaching, supporting various
 * recurrence patterns including daily, weekly, monthly, and custom patterns.
 *
 * @author Wilfred Njuguna
 * @version 1.0
 * @since 2024-09-05
 */
@Schema(
        name = "AvailabilitySlot",
        description = "Instructor availability slot that defines when an instructor is available for teaching",
        example = """
        {
            "uuid": "as123456-7890-abcd-ef01-234567890abc",
            "instructor_uuid": "inst1234-5678-90ab-cdef-123456789abc",
            "availability_type": "weekly",
            "day_of_week": 1,
            "day_of_month": null,
            "specific_date": null,
            "start_time": "09:00:00",
            "end_time": "17:00:00",
            "custom_pattern": null,
            "is_available": true,
            "recurrence_interval": 1,
            "effective_start_date": "2024-09-01",
            "effective_end_date": "2024-12-31",
            "created_date": "2024-09-05T10:00:00",
            "updated_date": "2024-09-05T15:30:00",
            "created_by": "instructor@sarafrika.com",
            "updated_by": "instructor@sarafrika.com"
        }
        """
)
public record AvailabilitySlotDTO(

        @Schema(
                description = "**[READ-ONLY]** Unique system identifier for the availability slot. Auto-generated by the system.",
                example = "as123456-7890-abcd-ef01-234567890abc",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "uuid", access = JsonProperty.Access.READ_ONLY)
        UUID uuid,

        @Schema(
                description = "**[REQUIRED]** Reference to the instructor UUID for this availability slot.",
                example = "inst1234-5678-90ab-cdef-123456789abc",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Instructor UUID is required")
        @JsonProperty("instructor_uuid")
        UUID instructorUuid,

        @Schema(
                description = "**[REQUIRED]** Type of availability pattern.",
                example = "weekly",
                allowableValues = {"daily", "weekly", "monthly", "custom"},
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Availability type is required")
        @JsonProperty("availability_type")
        AvailabilityType availabilityType,

        @Schema(
                description = "**[CONDITIONAL]** Day of the week (1=Monday, 7=Sunday). Required for weekly availability type.",
                example = "1",
                minimum = "1",
                maximum = "7",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Min(value = 1, message = "Day of week must be between 1 and 7")
        @Max(value = 7, message = "Day of week must be between 1 and 7")
        @JsonProperty("day_of_week")
        Integer dayOfWeek,

        @Schema(
                description = "**[CONDITIONAL]** Day of the month (1-31). Required for monthly availability type.",
                example = "15",
                minimum = "1",
                maximum = "31",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Min(value = 1, message = "Day of month must be between 1 and 31")
        @Max(value = 31, message = "Day of month must be between 1 and 31")
        @JsonProperty("day_of_month")
        Integer dayOfMonth,

        @Schema(
                description = "**[CONDITIONAL]** Specific date for one-time availability. Used with custom patterns.",
                example = "2024-09-15",
                format = "date",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("specific_date")
        LocalDate specificDate,

        @Schema(
                description = "**[REQUIRED]** Start time of the availability slot.",
                example = "09:00:00",
                format = "time",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "Start time is required")
        @JsonProperty("start_time")
        LocalTime startTime,

        @Schema(
                description = "**[REQUIRED]** End time of the availability slot.",
                example = "17:00:00",
                format = "time",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "End time is required")
        @JsonProperty("end_time")
        LocalTime endTime,

        @Schema(
                description = "**[CONDITIONAL]** Custom pattern expression for complex availability rules. Required for custom availability type.",
                example = "0 0 9 ? * MON-FRI",
                maxLength = 255,
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("custom_pattern")
        String customPattern,

        @Schema(
                description = "**[OPTIONAL]** Whether this slot represents availability (true) or blocked time (false).",
                example = "true",
                nullable = false,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("is_available")
        Boolean isAvailable,

        @Schema(
                description = "**[OPTIONAL]** Interval for recurrence. For example, 2 means every 2 weeks for weekly type.",
                example = "1",
                minimum = "1",
                maximum = "52",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Positive(message = "Recurrence interval must be positive")
        @Max(value = 52, message = "Recurrence interval must not exceed 52")
        @JsonProperty("recurrence_interval")
        Integer recurrenceInterval,

        @Schema(
                description = "**[OPTIONAL]** Date when this availability pattern becomes effective.",
                example = "2024-09-01",
                format = "date",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("effective_start_date")
        LocalDate effectiveStartDate,

        @Schema(
                description = "**[OPTIONAL]** Date when this availability pattern expires.",
                example = "2024-12-31",
                format = "date",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("effective_end_date")
        LocalDate effectiveEndDate,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the availability slot was first created. Automatically set by the system.",
                example = "2024-09-05T10:00:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime createdDate,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the availability slot was last modified. Automatically updated by the system.",
                example = "2024-09-05T15:30:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime updatedDate,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who created this availability slot.",
                example = "instructor@sarafrika.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_by", access = JsonProperty.Access.READ_ONLY)
        String createdBy,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who last modified this availability slot.",
                example = "instructor@sarafrika.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_by", access = JsonProperty.Access.READ_ONLY)
        String updatedBy,

        @Schema(
                description = "**[OPTIONAL]** Hex color code for blocked time visualization (e.g., for categorizing different types of blocked times).",
                example = "#FF6B6B",
                pattern = "^#[0-9A-Fa-f]{6}$",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty("color_code")
        String colorCode

) {

    /**
     * Returns the duration of this availability slot in minutes.
     *
     * @return Duration in minutes
     */
    @JsonProperty(value = "duration_minutes", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Duration of the availability slot in minutes.",
            example = "480",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public long getDurationMinutes() {
        if (startTime == null || endTime == null) {
            return 0;
        }
        return java.time.Duration.between(startTime, endTime).toMinutes();
    }

    /**
     * Returns a human-readable duration string.
     *
     * @return Formatted duration (e.g., "8h", "4h 30m")
     */
    @JsonProperty(value = "duration_formatted", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable formatted duration.",
            example = "8h",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getDurationFormatted() {
        long minutes = getDurationMinutes();
        if (minutes <= 0) {
            return "0m";
        }

        long hours = minutes / 60;
        long remainingMinutes = minutes % 60;

        if (hours > 0 && remainingMinutes > 0) {
            return hours + "h " + remainingMinutes + "m";
        } else if (hours > 0) {
            return hours + "h";
        } else {
            return remainingMinutes + "m";
        }
    }

    /**
     * Returns a human-readable time range string.
     *
     * @return Formatted time range (e.g., "09:00 - 17:00")
     */
    @JsonProperty(value = "time_range", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable time range.",
            example = "09:00 - 17:00",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getTimeRange() {
        if (startTime == null || endTime == null) {
            return "Invalid time range";
        }
        return startTime.toString() + " - " + endTime.toString();
    }

    /**
     * Checks if this availability slot is currently active based on effective dates.
     *
     * @return true if currently active, false otherwise
     */
    @JsonProperty(value = "is_currently_active", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if the availability slot is currently active based on effective dates.",
            example = "true",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isCurrentlyActive() {
        LocalDate today = LocalDate.now();
        
        boolean afterStartDate = effectiveStartDate == null || !today.isBefore(effectiveStartDate);
        boolean beforeEndDate = effectiveEndDate == null || !today.isAfter(effectiveEndDate);
        
        return afterStartDate && beforeEndDate && Boolean.TRUE.equals(isAvailable);
    }

    /**
     * Returns the availability type description.
     *
     * @return Human-readable availability type description
     */
    @JsonProperty(value = "availability_description", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable description of the availability pattern.",
            example = "Weekly on Monday",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getAvailabilityDescription() {
        if (availabilityType == null) {
            return "Unknown availability type";
        }

        return switch (availabilityType) {
            case DAILY -> "Daily availability";
            case WEEKLY -> "Weekly" + (dayOfWeek != null ? " on " + getDayName(dayOfWeek) : "");
            case MONTHLY -> "Monthly" + (dayOfMonth != null ? " on day " + dayOfMonth : "");
            case CUSTOM -> "Custom pattern" + (customPattern != null ? " (" + customPattern + ")" : "");
        };
    }

    /**
     * Helper method to get day name from day number.
     *
     * @param day Day number (1=Monday, 7=Sunday)
     * @return Day name
     */
    private String getDayName(int day) {
        return switch (day) {
            case 1 -> "Monday";
            case 2 -> "Tuesday";
            case 3 -> "Wednesday";
            case 4 -> "Thursday";
            case 5 -> "Friday";
            case 6 -> "Saturday";
            case 7 -> "Sunday";
            default -> "Unknown day";
        };
    }
}