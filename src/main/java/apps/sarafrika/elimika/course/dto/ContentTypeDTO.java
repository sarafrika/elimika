package apps.sarafrika.elimika.course.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.*;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Content Type Data Transfer Object
 * <p>
 * Represents supported content types for lessons in the Sarafrika Elimika system,
 * defining file formats, size limits, and MIME type restrictions.
 *
 * @author Wilfred Njuguna
 * @version 1.0
 * @since 2024-06-30
 */
@Schema(
        name = "ContentType",
        description = "Supported content type with file format specifications and size limits",
        example = """
        {
            "uuid": "c1o2n3t4-5e6n-7t8t-9y10-abcdefghijkl",
            "name": "Video",
            "mime_types": ["video/mp4", "video/webm", "video/mpeg"],
            "max_file_size_mb": 500,
            "created_date": "2024-04-01T12:00:00",
            "created_by": "system",
            "updated_date": "2024-04-15T15:30:00",
            "updated_by": "admin@sarafrika.com",
            "supported_formats": "MP4, WebM, MPEG",
            "size_limit_display": "500 MB",
            "is_media_type": true,
            "upload_category": "Large Media Files"
        }
        """
)
public record ContentTypeDTO(

        @Schema(
                description = "**[READ-ONLY]** Unique system identifier for the content type. Auto-generated by the system.",
                example = "c1o2n3t4-5e6n-7t8t-9y10-abcdefghijkl",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "uuid", access = JsonProperty.Access.READ_ONLY)
        UUID uuid,

        @Schema(
                description = "**[REQUIRED]** Name of the content type. Must be unique across all content types.",
                example = "Video",
                requiredMode = Schema.RequiredMode.REQUIRED,
                maxLength = 50
        )
        @NotBlank(message = "Content type name is required")
        @Size(max = 50, message = "Name must not exceed 50 characters")
        @JsonProperty("name")
        String name,

        @Schema(
                description = "**[REQUIRED]** Array of supported MIME types for this content type.",
                example = "[\"video/mp4\", \"video/webm\", \"video/mpeg\"]",
                requiredMode = Schema.RequiredMode.REQUIRED
        )
        @NotNull(message = "MIME types are required")
        @Size(min = 1, message = "At least one MIME type must be specified")
        @JsonProperty("mime_types")
        String[] mimeTypes,

        @Schema(
                description = "**[OPTIONAL]** Maximum file size allowed in megabytes. Null means no size limit.",
                example = "500",
                minimum = "1",
                nullable = true,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @Min(value = 1, message = "Maximum file size must be at least 1 MB")
        @JsonProperty("max_file_size_mb")
        Integer maxFileSizeMb,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the content type was created. Automatically set by the system.",
                example = "2024-04-01T12:00:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime createdDate,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who created this content type. Used for audit trails.",
                example = "system",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "created_by", access = JsonProperty.Access.READ_ONLY)
        String createdBy,

        @Schema(
                description = "**[READ-ONLY]** Timestamp when the content type was last modified. Automatically updated by the system.",
                example = "2024-04-15T15:30:00",
                format = "date-time",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_date", access = JsonProperty.Access.READ_ONLY)
        LocalDateTime updatedDate,

        @Schema(
                description = "**[READ-ONLY]** Email or username of the user who last modified this content type. Used for audit trails.",
                example = "admin@sarafrika.com",
                accessMode = Schema.AccessMode.READ_ONLY,
                requiredMode = Schema.RequiredMode.NOT_REQUIRED
        )
        @JsonProperty(value = "updated_by", access = JsonProperty.Access.READ_ONLY)
        String updatedBy

) {

    /**
     * Returns a formatted list of supported file formats.
     *
     * @return Comma-separated list of supported formats
     */
    @JsonProperty(value = "supported_formats", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable list of supported file formats.",
            example = "MP4, WebM, MPEG",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getSupportedFormats() {
        if (mimeTypes == null || mimeTypes.length == 0) {
            return "No formats specified";
        }

        return java.util.Arrays.stream(mimeTypes)
                .map(mimeType -> mimeType.substring(mimeType.indexOf('/') + 1).toUpperCase())
                .distinct()
                .collect(java.util.stream.Collectors.joining(", "));
    }

    /**
     * Returns a formatted display string for file size limit.
     *
     * @return Formatted size limit or "No limit" if not set
     */
    @JsonProperty(value = "size_limit_display", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Human-readable format of maximum file size.",
            example = "500 MB",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getSizeLimitDisplay() {
        if (maxFileSizeMb == null) {
            return "No limit";
        }
        return maxFileSizeMb + " MB";
    }

    /**
     * Checks if this is a media content type (video, audio, image).
     *
     * @return true if content type is for media files
     */
    @JsonProperty(value = "is_media_type", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Indicates if this content type is for media files.",
            example = "true",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public boolean isMediaType() {
        if (mimeTypes == null || mimeTypes.length == 0) {
            return false;
        }

        return java.util.Arrays.stream(mimeTypes)
                .anyMatch(mime -> mime.startsWith("video/") ||
                        mime.startsWith("audio/") ||
                        mime.startsWith("image/"));
    }

    /**
     * Returns a category for upload organization based on content type.
     *
     * @return Upload category for UI organization
     */
    @JsonProperty(value = "upload_category", access = JsonProperty.Access.READ_ONLY)
    @Schema(
            description = "**[READ-ONLY]** Category for organizing uploads in the user interface.",
            example = "Large Media Files",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    public String getUploadCategory() {
        if (name == null) {
            return "Unknown";
        }

        String lowerName = name.toLowerCase();
        if (lowerName.contains("video")) {
            return "Large Media Files";
        } else if (lowerName.contains("audio")) {
            return "Audio Files";
        } else if (lowerName.contains("image")) {
            return "Images";
        } else if (lowerName.contains("pdf")) {
            return "Documents";
        } else if (lowerName.contains("text")) {
            return "Text Content";
        } else {
            return "Other Files";
        }
    }
}